# Продвинутые темы и техники C++
## Урок 13. Дополнительные возможности классов и умные указатели

### Цели практической работы
* Закрепить навыки работы с классами в C++.
* Разобраться с механикой работы умных указателей с подсчётом ссылок.
* Освоить использование перегрузки методов класса.

### Что входит в работу
1. Использование умного указателя.
2. Реализация умного указателя.
3. Реализация класса графа (дополнительное задание).

## 1. Использование умного указателя

### Что нужно сделать
1. Реализуйте класс Dog, который использует стандартный умный указатель shared_ptr для класса Toy.
2. Реализуйте у класса Dog метод getToy, с помощью которого собака подбирает игрушку.
    - Если у собаки уже есть эта игрушка, необходимо вывести в консоль фразу: I already have this toy.
    - Если в данный момент игрушка находится у другой собаки, нужно вывести в консоль: Another dog is playing with this toy.
    - Если игрушка свободна, собака подбирает её.
3. Реализуйте у класса Dog метод dropToy, с помощью которого собака бросает игрушку на пол, после чего другая может подобрать её.
    - Если у собаки в этот момент нет игрушки, в консоль необходимо вывести: Nothing to drop.

### Советы и рекомендации

* Чтобы узнать, у скольких собак в данный момент есть игрушка, можно использовать метод use_count() у класса shared_ptr. При этом необходимо учитывать, что создание shared_ptr от класса Toy тоже увеличивает показатели счётчика.
* Чтобы увидеть удаление класса Toy, используйте следующее определение:

```
class Toy {
public:
Toy(const std::string& name) {
name_ = name;
}
std::string getNmae() {
return name_;
}
~Toy() {
std::cout << "Toy " << name_ << " was dropped " << std::endl;
}
private:
std::string name_;
};

```

## 2. Реализация умного указателя

### Что нужно сделать
1. Реализуйте умный указатель shared_ptr_toy с распределённым доступом и механикой подсчёта ссылок для класса Toy, реализованного в задании.
Указатель должен:
    - иметь все стандартные методы класса,
    - быть функциональной заменой использованию shared_ptr<Toy>.
2. Реализуйте свободную функцию make_shared_toy, которая принимает набор аргументов и конструирует игрушку от названия или при помощи копии другой игрушки.

### Советы и рекомендации
Не забудьте уменьшить число ссылок на единицу в деструкторе умного указателя. Когда на счётчике появится значение 0, удалите объект.
* Вы можете использовать перегрузки под разные типы. Их количество ограничено.

### Чек-лист для проверки задания
* Класс называется shared_ptr_toy.
* Реализованы конструктор, конструктор копий, оператор присваивания копированием, деструктор и функция make_shared.


## 3. Реализация класса графа (дополнительное задание)

### Что нужно сделать
1. Прочитайте, что такое графы в дискретной математике, как граф можно представить в программе, что такое матрицы смежности и списки смежности:
    - «Просто о графах. Попытка популяризации»;
    - «Теория графов. Дискретная математика»;
    - «Представление графа с помощью матриц смежности, инцидентности и списков смежности».
2. У вас есть базовый интерфейс для представления ориентированного графа. Напишите две реализации интерфейса:
ListGraph, хранящий граф в виде массива списков смежности;
MatrixGraph, хранящий граф в виде матрицы смежности.
3. Реализуйте конструктор, принимающий IGraph. Такой конструктор должен скопировать переданный граф в создаваемый объект. Обратите внимание, что иногда в одну реализацию графа копируется другая. Реализуйте все конструкторы копий и операторы присваивания, если это необходимо.

### Советы и рекомендации
Во всех алгоритмах поиска вам потребуются рёбра для вершин. Для этого используйте std::unordered_set и его метод contains.
Пример кода:
```
class IGraph {
public:
virtual ~IGraph() {}
IGraph() {};
IGraph(IGraph *_oth) {};
virtual void AddEdge(int from, int to) = 0; // Метод принимает вершины начала и конца ребра и добавляет ребро
virtual int VerticesCount() const = 0; // Метод должен считать текущее количество вершин
virtual void GetNextVertices(int vertex, std::vector<int> &vertices) const = 0; // Для конкретной вершины метод выводит в вектор «вершины» все вершины, в которые можно дойти по ребру из данной
virtual void GetPrevVertices(int vertex, std::vector<int> &vertices) const = 0; // Для конкретной вершины метод выводит в вектор «вершины» все вершины, из которых можно дойти по ребру в данную
};
```
### Чек-лист для проверки задания
* Реализованы два класса-наследника, имплементирующие корректные алгоритмы работы с графом как с матрицей смежности и списками смежности.

Что оценивается
Корректность и совместимость представлений графов двумя разными способами.